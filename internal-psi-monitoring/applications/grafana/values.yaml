replicas: 3 # Changed from 3 to 1 to fix DB migration lock race condition. Scale back to 3 after first healthy deploy.

deploymentStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 0

# 0. ENABLE HEADLESS SERVICE (CRITICAL FIX)
# This creates the 'grafana-headless' Kubernetes Service.
# Without this, the 'ha_peers' DNS lookup below fails with "server misbehaving".
headlessService: true

# 1. INJECT PASSWORD SECURELY
# Map the Kubernetes Secret key to an Environment Variable
envValueFrom:
  GF_DATABASE_PASSWORD:
    secretKeyRef:
      name: grafana-db
      key: password

# 2. CONFIGURE GRAFANA.INI
# All config must go here. We use the Env Var for the password.
grafana.ini:
  server:
    enable_gzip: true
  database:
    type: postgres
    host: pg-1e155c21-oyegokeodev-f11d.f.aivencloud.com:20109
    name: grafana
    user: grafana_user
    password: $__env{GF_DATABASE_PASSWORD}
    ssl_mode: require
  session:
    provider: database
  # 3. UNIFIED ALERTING FOR HA
  # Ensures alerts are not sent duplicate times by different replicas.
  # Requires 'headlessService: true' above.
  unified_alerting:
    enabled: true
    ha_peers: "grafana-headless:9094" 

# 4. PERSISTENCE IN HA
# RWO volumes fail with replicas: 3. 
# Since you use external Postgres for data, users, and dashboards,
# we can disable local storage.
persistence:
  enabled: false

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  ingressClassName: nginx
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - grafana.example.com
  tls:
    - secretName: grafana-tls
      hosts:
        - grafana.example.com

readinessProbe:
  httpGet:
    path: /api/health
    port: 3000
  initialDelaySeconds: 30

livenessProbe:
  httpGet:
    path: /api/health
    port: 3000
  initialDelaySeconds: 60